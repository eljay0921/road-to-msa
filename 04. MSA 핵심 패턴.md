# MSA 핵심 패턴



## 4-1. 들어가며

MSA는 구조적으로는 ‘서비스를 분리한다’는 간단한 개념처럼 보이지만, 실제 운영 단계에서는 그보다 훨씬 복잡한 문제가 등장한다. 서비스 간 통신, 데이터 정합성, 장애 전파, 요청 추적 등 모놀리식에서는 신경 쓰지 않아도 됐던 영역들이 새롭게 부상한다.

이를 해결하기 위해 등장한 것이 **MSA 패턴(Microservice Patterns)** 이다. 이들은 마이크로서비스 아키텍처에서 반복적으로 마주치는 문제를 해결하기 위한 **설계 규칙, 운영 기법, 아키텍처적 사고 방식**이라 할 수 있다.



## 4-2. 서비스 간 통신 패턴

### 💡 동기식 통신 – REST, gRPC

가장 직관적인 방식은 HTTP 기반의 **REST API** 호출이다. 단순하지만 서비스 간 의존성이 강해지고, 한쪽 장애가 다른 서비스로 전파될 수 있다.

이때 **gRPC**는 바이너리 기반의 고성능 RPC 프레임워크로, 대규모 서비스 간 저지연 통신이나 언어 간 호출(Java ↔ Go 등)에 유용하다. 단, 버전 관리나 backward compatibility를 명확히 설계해야 한다.

> ⚙️ **실무 포인트:**  
> REST는 단순하지만 느리고, gRPC는 빠르지만 관리가 어렵다.  
> 두 방식 모두 Circuit Breaker와 Retry 정책을 반드시 포함해야 한다.

### 💡 비동기식 통신 – 이벤트 기반 아키텍처 (EDA)

서비스 간 결합도를 줄이기 위한 가장 강력한 방법은 **이벤트 기반(Event-Driven)** 구조다. Kafka, RabbitMQ, SNS/SQS 같은 메시지 브로커를 통해 “이벤트 발행-구독(Publish/Subscribe)” 모델로 서비스가 느슨하게 연결된다.

예를 들어, 주문 서비스가 “주문 완료” 이벤트를 발행하면 결제 서비스가 이를 구독해 결제 트랜잭션을 처리하고, 알림 서비스는 별도로 푸시 메시지를 전송한다.

> ⚙️ **실무 포인트:**  
> 이벤트 메시지에는 반드시 **idempotency key(중복 방지 키)** 를 포함해  
> 재시도나 중복 소비에도 데이터 정합성을 보장해야 한다.

### 비교

| 패턴                           | 특징                                                         | 예시 기술                                    | 장점                                                         | 단점                                                         |
| ------------------------------ | ------------------------------------------------------------ | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **동기 통신** (Synchronous)    | 요청-응답 방식. 호출자가 응답을 받을 때까지 대기.            | **HTTP (RESTful API), gRPC**                 | 구현이 직관적, 즉각적인 응답 필요 시 적합.                   | 서비스 간 결합도 증가, 호출 서비스의 장애가 호출한 서비스로 전파될 위험(Cascading Failure), 대기 시간 발생. |
| **비동기 통신** (Asynchronous) | 메시징 시스템을 사용하며, 호출자가 응답을 기다리지 않음. 메시지 발행(Publishing) 및 구독(Subscribing). | **Message Broker (Kafka, RabbitMQ, SQS 등)** | 서비스 간 **느슨한 결합** (Decoupling), 장애 격리 용이, 높은 확장성. | 구현의 복잡성 증가, 즉각적인 응답을 기대하기 어려움, 최종 일관성 문제. |



## 4-3. 데이터 일관성 패턴

MSA에서 각 서비스는 독립적인 데이터베이스를 가지므로, 여러 서비스에 걸친 비즈니스 트랜잭션(**분산 트랜잭션**)의 데이터 일관성을 유지하는 것이 중요하다. 기존 모놀리식의 2PC(Two-Phase Commit) 방식은 MSA 환경에 적합하지 않으며, 주로 **최종 일관성(Eventual Consistency)** 을 활용하는 패턴을 사용한다.

### 💡 Saga 패턴

**Saga 패턴**은 분산 트랜잭션을 일련의 **로컬 트랜잭션** 시퀀스로 관리한다. 각 로컬 트랜잭션은 해당 서비스를 업데이트하고 **이벤트**를 발행하여 다음 서비스를 트리거한다.

- **성공 시:** 모든 로컬 트랜잭션이 순서대로 실행된다.
- **실패 시:** 이전 트랜잭션들의 변경사항을 되돌리기 위해 **보상 트랜잭션(Compensation Transaction)** 을 실행한다.

Saga 패턴의 구현 방식은 두 가지이다.

1. **Choreography (안무):** 각 서비스가 발행된 이벤트를 구독하고, 각자 다음 단계를 결정하는 분산 방식. 서비스 간 의존성이 낮지만, 복잡한 워크플로우 추적이 어려움.
   
2. **Orchestration (오케스트레이션):** 중앙의 **오케스트레이터(Orchestrator) 서비스**가 트랜잭션의 전체 흐름을 관리하고 각 참여 서비스에 실행 명령을 내리는 중앙 집중식 방식. 흐름 파악이 용이하지만, 오케스트레이터 서비스가 단일 장애 지점이 될 수 있음.



## 4-4. 장애 격리 및 회복 패턴

MSA 환경에서는 한 서비스의 장애가 시스템 전체로 전파되는 **연쇄 장애(Cascading Failure)** 를 막기 위해 **내결함성(Fault Tolerance)** 을 확보해야 한다.

### 💡 서킷 브레이커 패턴 (Circuit Breaker Pattern)

원격 서비스 호출 시 실패율이나 응답 지연이 임계치를 넘어서면, 해당 서비스에 대한 추가 호출을 **즉시 차단**하고 폴백(Fallback) 응답을 반환하여 장애가 전파되는 것을 방지한다.

- **Closed:** 정상 상태. 요청을 통과시킴.
  
- **Open:** 장애 발생 상태. 일정 시간 동안 모든 요청을 차단하고 즉시 실패 응답 반환.
  
- **Half-Open:** Open 상태 이후 잠시 일부 요청을 허용하여 서비스 복구 여부를 테스트.
  

### 💡 벌크헤드 패턴 (Bulkhead Pattern)

특정 자원에 대한 동시성 제한을 통해 서비스 리소스를 **격리**한다. 예를 들어, 각 외부 서비스 호출을 위한 **별도의 스레드 풀**을 사용하여, 한 서비스의 지연이나 장애가 다른 서비스의 리소스를 고갈시키지 않도록 한다.

### 💡 타임아웃/재시도 패턴 (Timeout/Retry Pattern)

- **타임아웃:** 서비스 호출 시 최대 대기 시간을 설정하여, 응답이 지연될 경우 빠르게 연결을 끊고 리소스를 해제한다 (**Fast Fail**).
  
- **재시도:** 일시적인 네트워크 오류나 서비스 가용성 문제에 대응하기 위해, 실패한 요청을 일정 시간 후 다시 시도한다. (Expotential Backoff, Jitter 전략 필요)



## 4-5. API 게이트웨이와 서비스 디스커버리

### 💡 API 게이트웨이 (API Gateway)

클라이언트(웹, 모바일 등)의 모든 요청을 받아 적절한 마이크로서비스로 라우팅하는 **단일 진입점(Single Entry Point)** 역할을 합니다.

- **주요 기능:** 요청 라우팅, 인증/인가, 로드 밸런싱, 요청 로깅, 속도 제한(Rate Limiting), 프로토콜 변환(예: HTTP를 gRPC로).
  
- **장점:** 클라이언트-서비스 간 결합도 감소, 클라이언트 코드 단순화, 공통 기능 중앙 집중화.
  

### 💡 서비스 디스커버리 (Service Discovery)

MSA 환경에서 서비스 인스턴스의 네트워크 위치(호스트 및 포트)는 동적으로 변한다. 서비스 디스커버리는 이 정보를 관리하고, 클라이언트나 API 게이트웨이가 필요한 서비스 인스턴스를 찾을 수 있도록 도와준다.

- **서비스 레지스트리 (Service Registry):** 서비스 인스턴스의 위치 정보를 저장하는 중앙 저장소 (예: Eureka, ZooKeeper, Consul).
  
- **유형:**
    - **클라이언트 측 디스커버리 (Client-Side Discovery):** 클라이언트(또는 API Gateway)가 레지스트리에서 서비스 위치를 직접 조회 후 호출.
    - **서버 측 디스커버리 (Server-Side Discovery):** 라우터나 로드 밸런서가 서비스 위치를 조회하여 요청을 포워딩.



## 4-6. 서비스 간 데이터 공유 패턴

MSA의 기본 원칙은 서비스가 자체 데이터베이스를 갖고 독립적으로 운영되는 것이다. 서비스 간 직접적인 데이터베이스 공유(Shared Database)는 결합도를 높이고 독립성을 해치므로 피해야 한다. 대신, 다음 패턴들을 사용하여 데이터를 공유한다.

### 💡 API Composition (API 조합)

클라이언트가 필요로 하는 데이터를 여러 서비스의 API를 호출하여 취합(Aggregating)하고 조합하여 응답을 생성한다. API 게이트웨이나 전용 조합 서비스(Aggregator Service)에서 이 역할을 수행할 수 있다. (ex. BFF, API Gateway, ...)

### 💡 Event-Driven Data Sharing (이벤트 기반 데이터 공유)

데이터 변경이 필요한 서비스가 해당 이벤트를 발행하면, 데이터를 필요로 하는 다른 서비스들이 이를 구독하여 **자체 데이터 저장소**를 업데이트한다.

- 예: **CQRS (Command Query Responsibility Segregation)** 패턴을 결합하여, 쓰기 모델(Command)은 원천 서비스에서 관리하고, 읽기 모델(Query)은 이벤트 구독을 통해 다른 서비스의 전용 데이터 저장소에 복제 및 최적화하여 사용.



## 4-7. 내결함성과 관측성 (Observability)

**내결함성(Fault Tolerance)** 은 4-4에서 설명된 패턴들(서킷 브레이커, 벌크헤드 등)을 통해 시스템의 부분적인 장애에도 전체 시스템이 기능을 유지하도록 하는 능력이다.

**관측성(Observability)** 은 시스템의 외부 출력(로그, 메트릭, 트레이스)을 분석하여 시스템의 내부 상태를 얼마나 잘 이해할 수 있는지를 나타내는 척도로, 분산된 MSA 환경에서 문제 발생 시 원인을 빠르게 파악하고 해결하기 위해 매우 중요하다.

### 💡 관측성의 3가지 기둥 (The Three Pillars of Observability)

1. **로깅 (Logging):** 애플리케이션의 특정 시점에 대한 이산적인 이벤트 기록. **중앙 집중식 로깅 시스템** (예: ELK Stack/Loki)을 구축하여 모든 서비스의 로그를 수집하고 분석.
   
2. **메트릭 (Metrics):** 시간 경과에 따른 수치 데이터. 시스템의 성능과 상태를 정량적으로 파악 (예: CPU 사용률, 요청 처리량, 지연 시간). (예: Prometheus, Grafana)
   
3. **분산 추적 (Distributed Tracing):** 하나의 외부 요청이 여러 마이크로서비스를 거치며 처리되는 전체 흐름을 추적합니다. 서비스 간의 호출 관계와 각 단계에서 소요된 시간을 파악하여 병목 현상이나 장애 지점을 신속하게 식별. (예: Zipkin, Jaeger, OpenTelemetry)

