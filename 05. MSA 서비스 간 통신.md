# MSA 서비스 간 통신



## 5-1. 개요: 분산 시스템에서의 ‘대화 규칙’

마이크로서비스 아키텍처(MSA)에서 각 서비스는 독립된 실행 단위로 분리되어 있지만, 비즈니스 로직은 여전히 여러 서비스를 거치며 완성된다. 예를 들어 ‘주문’은 상품, 결제, 재고, 배송 서비스를 차례로 호출해야 성립한다.

즉, MSA의 본질적인 복잡성은 **“서비스 간 대화(communication)”** 에서 발생한다. 이 통신이 느리거나 불안정하면, 아무리 좋은 코드 구조도 무용지물이 된다. 따라서 MSA를 설계할 때 가장 먼저 고민해야 하는 것은 “서비스들이 어떤 방식으로, 언제, 어떤 책임으로 대화할 것인가”이다.

통신 패턴은 크게 **동기식(Synchronous)** 과 **비동기식(Asynchronous)** 으로 나뉜다. 각각의 장단점을 이해하고, 상황에 따라 적절히 섞어 쓰는 것이 핵심이다.

## 5-2. 동기 통신 (REST API, gRPC)

### 🔹 REST API

가장 널리 쓰이는 통신 방식으로, HTTP 프로토콜 위에서 JSON 형태로 데이터를 교환한다. REST는 **리소스 중심** 설계를 기반으로 하며, URI와 HTTP 메서드(GET, POST, PUT, DELETE)로 의도를 표현한다. 예를 들어 `/orders/123`는 주문 리소스를 의미하고, `GET`은 조회, `DELETE`는 삭제를 의미한다.

- **장점**
  - 단순하고 범용적이다. 거의 모든 언어와 플랫폼에서 쉽게 구현 가능.
  - 브라우저, 모바일, 외부 파트너 연동에도 적합하다.
  - HTTP 인프라(CDN, 캐시, 프록시)를 그대로 활용할 수 있다.
- **단점**
  - 텍스트(JSON) 기반이라 데이터가 크고 느리다.
  - 서비스 간 호출 체인이 길어질수록 지연과 장애 전파 위험이 커진다.

> 💡 실무 팁
>
> - REST 호출에는 **timeout, retry, circuit breaker** 를 반드시 설정해야 한다.
> - 클라이언트와 서버가 독립적으로 진화할 수 있도록 **버저닝과 계약 테스트**를 병행한다.

### 🔹 gRPC

gRPC는 Google이 개발한 **고성능 RPC(Remote Procedure Call)** 프레임워크다. HTTP/2 프로토콜을 사용하고, 데이터를 **Protocol Buffers (Protobuf)** 로 직렬화하여 전송한다. 즉, 텍스트 대신 **바이너리 데이터**를 교환하기 때문에 훨씬 빠르고 효율적이다.

- **장점**
  - 속도가 빠르고, 요청·응답뿐 아니라 스트리밍(양방향)도 지원한다.
  - `.proto` 스키마 기반으로 다국어(Java, Go, Python 등) 간 호환이 좋다.
  - 내부 마이크로서비스 간 통신(서버↔서버)에 특히 적합하다.
- **단점**
  - 브라우저 호출은 직접적으로 어렵다. (보통 API Gateway가 변환 담당)
  - 스키마 버전 관리가 필수이며, 호환성(Backward Compatibility)을 엄격히 지켜야 한다.

> 💡 실무 팁
>
> - `.proto` 파일은 중앙 저장소에서 버전 관리한다.
> - 새 필드는 **optional** 로 추가하고, 필드 번호는 재사용하지 않는다.
> - 클라이언트보다 **서버를 먼저 배포**하는 순서를 지켜야 한다.

## 5-3. 비동기 통신 (메시지 큐, 이벤트 기반)

비동기 통신은 요청-응답이 즉시 이루어지지 않고, **메시지나 이벤트를 매개로 시간적으로 분리된 통신**을 말한다. 서비스 간 결합도를 낮추고, 트래픽 폭주나 일시적 장애에도 견디는 구조를 만든다.

### 🔹 메시지 큐 (Message Queue)

하나의 서비스가 메시지를 큐에 넣고, 다른 서비스가 꺼내 처리하는 방식이다. `RabbitMQ`, `AWS SQS`, `ActiveMQ` 등이 대표적이다.

- **장점**
  - 전송 보장(ack/retry) 기능으로 안정성이 높다.
  - 생산자와 소비자가 독립적으로 작동한다.
  - 부하 분산과 비동기 처리(예: 이메일 발송, 알림 전송)에 적합.
- **단점**
  - 메시지 순서, 중복 처리, 재시도 로직 등 운영 복잡성이 증가.

### 🔹 이벤트 기반 아키텍처 (Event-Driven Architecture)

이벤트(Event)는 “사건의 발생 사실”을 뜻한다. 예: 주문 서비스가 “주문 생성됨(OrderCreated)” 이벤트를 발행하면, 결제 서비스가 이를 구독(Subscribe)해 결제 처리를 시작한다.

- **장점**
  - 서비스 간 **느슨한 결합(loose coupling)** 을 실현한다.
  - 여러 서비스가 동일 이벤트를 구독해 병렬 처리 가능.
  - 트래픽 급증 시 메시지 브로커가 완충 버퍼 역할을 수행한다.
- **단점**
  - 데이터 정합성(Eventual Consistency) 관리가 필요하다.
  - 이벤트 중복 또는 재처리 문제를 대비해야 한다.

> 💡 실무 팁
>
> - 이벤트에는 **멱등성 키(Idempotency Key)** 를 반드시 포함시킨다.
> - 장애 시 재처리를 위해 **Dead Letter Queue(DLQ)** 를 운영한다.
> - 중요 이벤트는 **모니터링 대시보드**에서 소비 상태를 시각화한다.

## 5-4. 메시지 브로커 (RabbitMQ, Kafka, AWS SQS)

메시지 브로커는 발행자와 구독자 사이에서 메시지를 안전하게 전달하고 저장하는 **중간자** 역할을 한다. 브로커의 특성에 따라 성격이 다르므로, 서비스 특성에 맞게 선택해야 한다.

| 브로커       | 특징                                                     | 주요 사용 사례                          |
| ------------ | -------------------------------------------------------- | --------------------------------------- |
| **RabbitMQ** | 큐 기반(AMQP), ACK/Retry/DLQ 등 신뢰성 높음              | 작업 큐, 비동기 명령 처리, 알림 시스템  |
| **Kafka**    | 로그 스트림 기반, 고처리량·다수 소비자 지원, 오프셋 관리 | 이벤트 스트리밍, 실시간 분석, 로그 수집 |
| **AWS SQS**  | 완전관리형 큐 서비스, 운영부담 최소                      | 간단한 비동기 처리, 소규모 시스템       |
| **AWS SNS**  | 토픽 기반 Pub/Sub, 팬아웃 구조                           | 알림·브로드캐스트 메시징                |

> 💡 실무 팁
>
> - RabbitMQ는 “작업 지시형(Command)”에, Kafka는 “사건 기록형(Event)”에 적합하다.
> - 운영 환경에서는 **모니터링·메트릭·리텐션 정책**을 명확히 설정해야 한다.
> - 트랜잭션 연동이 필요한 경우, Outbox 패턴으로 메시지 손실을 방지한다.

## 5-5. API 설계 원칙과 버저닝

서비스 간 통신이 성공적으로 지속되려면, 단순히 데이터를 주고받는 것보다 **명확하고 지속 가능한 계약(Contract)** 이 중요하다. 이 계약이 바로 “API”다.

### 🔹 API 설계 원칙

1. **명확한 리소스와 행위 구분**
   - URI는 명사(`/orders/123`), HTTP 메서드는 동사(`GET`, `POST`, `PATCH`).
   - 의미 없는 `/doSomething` 형태는 피한다.
2. **표준화된 응답 구조**
   - 성공: `200 OK`, `201 Created`, `204 No Content`
   - 실패: `4xx`(클라이언트 오류), `5xx`(서버 오류)
   - 응답 본문에는 `code`, `message`, `traceId` 등을 일관되게 포함.
3. **일관된 Naming과 규약**
   - snake_case vs camelCase 혼용 금지.
   - 필드명, 날짜·시간 형식(ISO 8601), 금액 단위 등 표준화.
4. **보안과 인증**
   - 서비스 간에는 **mTLS**(상호 TLS) 또는 **JWT 토큰 기반 인증**을 적용한다.
   - 최소 권한 원칙(Least Privilege) 준수.

### 🔹 API 버저닝 전략

시간이 지남에 따라 API 스펙은 진화해야 한다. 하지만 클라이언트가 모두 한 번에 바뀌지는 않는다. 그래서 **호환성을 유지하며 진화시키는 버전 전략**이 필요하다.

1. **URL 버전 방식**
   - `/api/v1/orders`, `/api/v2/orders`
   - 가장 명시적이지만, 중복 코드가 생기기 쉽다.
2. **헤더 버전 방식**
   - `Accept: application/vnd.company.v2+json`
   - URL은 그대로 두고, 헤더로 버전을 관리한다.
3. **점진적 호환성 유지**
   - 새 필드 추가는 Optional로.
   - 기존 필드·의미 제거는 새 버전에서만.
   - REST에서는 **하위 호환성(Backward Compatibility)** 유지가 가장 중요하다.

> 💡 실무 팁
>
> - API 스키마(OpenAPI/Swagger) 파일은 **Git 버전 관리** 대상이다.
> - 변경이 발생하면 **소비자 계약 테스트(Consumer Contract Test)** 로 검증한다.
> - deprecation 공지 → grace period → 완전 제거 순으로 진행한다.

## 마무리

MSA에서 “서비스 간 통신”은 단순한 기술 세부사항이 아니라 **시스템 전체의 안정성과 민첩성을 결정짓는 설계**이다.

- REST/gRPC는 **즉시성**을,
- 메시지 큐/이벤트는 **회복력과 유연성**을 제공한다.

좋은 시스템은 이 둘을 적절히 혼합해, 필요한 곳엔 빠른 응답을, 안정이 중요한 곳엔 비동기 완충을 배치한다. 즉, 통신 패턴의 선택은 **서비스의 성격을 정의하는 일**이다.