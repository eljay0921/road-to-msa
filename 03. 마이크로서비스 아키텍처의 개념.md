# 마이크로서비스 아키텍처의 개념



## 3-1. MSA의 정의와 핵심 원칙

**마이크로서비스 아키텍처(Microservices Architecture, 이하 MSA)** 란, 대규모 애플리케이션을 **작고 독립적인 서비스 단위**로 나누어 개발·배포·운영하는 방식이다. 각 서비스는 하나의 구체적인 비즈니스 기능(예: 주문, 결제, 회원관리)을 수행하며, 서비스 간에는 API나 메시지 큐 등을 통해 통신한다.

MSA는 단순히 “모놀리식 코드를 나누는 것”이 아니라, **조직 구조·개발 방식·운영 문화 전반의 분리와 자율성 확보**를 의미한다. 즉, 기술적 분할이 아니라 **업무 경계(Business Boundary)** 중심의 분할이 핵심이다.

MSA의 핵심 원칙은 다음과 같다.

1. **자율성과 독립성 (Independence)**
   각 서비스는 별도의 코드베이스와 데이터 저장소를 가진다.
   다른 서비스와의 결합을 최소화하여, 독립적인 빌드·배포·운영이 가능해야 한다.
2. **단일 책임 원칙 (Single Responsibility Principle)**
   하나의 마이크로서비스는 하나의 비즈니스 기능만 담당한다.
   예를 들어 “결제 서비스”가 회원가입 로직까지 담당해서는 안 된다.
3. **자체 데이터 소유 (Own Your Data)**
   서비스 간 DB를 공유하지 않고, 각 서비스가 자신의 데이터를 관리한다.
   데이터 정합성은 트랜잭션보다는 **이벤트 기반 비동기 처리**로 유지한다.
4. **자동화와 회복력 (Automation & Resilience)**
   서비스 수가 많아지므로, 수동 관리가 불가능하다.
   따라서 CI/CD, 헬스체크, 장애 복구, 스케일링이 자동화되어야 하며,
   장애에 대한 **복원력(Resilience)** 과 **관측성(Observability)** 이 내장되어야 한다.



## 3-2. 모놀리식 vs 마이크로서비스 비교

| 구분             | 모놀리식 아키텍처                      | 마이크로서비스 아키텍처            |
| ---------------- | -------------------------------------- | ---------------------------------- |
| **구조**         | 모든 기능이 하나의 애플리케이션에 통합 | 기능별로 분리된 다수의 독립 서비스 |
| **배포 단위**    | 전체 시스템 단일 배포                  | 서비스 단위 독립 배포              |
| **데이터베이스** | 공용 DB 하나                           | 서비스별 전용 DB (분리된 스키마)   |
| **확장성**       | 전체 시스템 단위로 확장 (비효율)       | 필요한 서비스만 선택적 확장        |
| **장애 영향**    | 하나의 장애가 전체 시스템에 전파       | 서비스 단위로 격리되어 영향 최소화 |
| **개발 조직**    | 기능 간 강한 의존, 병렬 개발 어려움    | 팀별 자율적 개발 가능              |
| **적합한 규모**  | 초기 MVP, 단순 서비스                  | 대규모 사용자, 복잡한 도메인       |

요약하자면, **모놀리식**은 단순성과 일관성이 장점이지만, 성장할수록 유지보수가 어려워지고 확장에 제약이 생긴다. 반면 **MSA**는 복잡성이 늘어나지만, 서비스의 자율성과 변화 대응력을 확보할 수 있다. 즉, **성숙한 팀 문화와 자동화 체계**가 있을수록 MSA의 장점이 빛난다.



## 3-3. MSA의 장단점과 적용 시나리오

### 장점

1. **확장성과 유연성**
   - 트래픽이 몰리는 기능만 독립적으로 확장 가능 (예: 결제, 상품 조회 등).
   - 특정 서비스의 장애가 전체 시스템을 멈추게 하지 않는다.
2. **배포 민첩성**
   - 서비스별로 배포 주기가 다르며, 기능 플래그나 카나리 배포가 용이하다.
   - 장애 발생 시 롤백이 빠르다.
3. **기술 다양성 (Polyglot Architecture)**
   - 서비스별로 가장 적합한 언어, 프레임워크, 데이터베이스 선택 가능.
   - 예: 주문은 Java + Oracle, 통계는 Python + BigQuery.
4. **조직 효율성**
   - 팀이 자신이 담당하는 서비스의 전체 생명주기를 관리(DevOps).
   - 코드·인프라 의존도가 줄어 협업 속도가 빨라진다.

### 단점

1. **운영 복잡도 증가**
   - 서비스 수가 많아질수록 배포, 모니터링, 보안 관리가 어려워진다.
   - Kubernetes, Service Mesh, CI/CD 자동화가 필수화된다.
2. **데이터 정합성 이슈**
   - 분산 환경에서는 트랜잭션을 통합적으로 처리하기 어렵다.
   - **Saga 패턴**, **Eventual Consistency** 등을 고려해야 한다.
3. **관측성 부족**
   - 호출 경로가 복잡해지며 장애 원인 추적이 어렵다.
   - **분산 트레이싱(OpenTelemetry, Jaeger)** 이 필요하다.
4. **과도한 설계의 위험**
   - 시스템 규모나 팀이 작을 경우 오히려 오버엔지니어링이 될 수 있다.

### 적용 시나리오

- ✅ 트래픽이 많은 대규모 B2C 서비스 (e-commerce, 게임, 스트리밍 등)
- ✅ 도메인이 복잡하고 조직이 여러 팀으로 나뉜 환경
- ✅ 지속적인 기능 확장과 잦은 배포가 필요한 서비스
- ⚠️ 반면, 스타트업 초기나 소규모 시스템에는 오히려 불필요한 복잡성을 초래할 수 있음.



## 3-4. 서비스 분리 전략

### (Domain-Driven Design과 Bounded Context)

MSA의 성공 여부는 “서비스를 어떻게 나누는가”에 달려 있다. 즉, **서비스 경계(Service Boundary)** 를 기술적으로가 아니라 **도메인(Domain)** 중심으로 정의해야 한다.

이를 돕는 대표적인 접근 방식이 **도메인 주도 설계(DDD: Domain-Driven Design)** 이다.

1. **도메인 모델(Domain Model)**
   - 비즈니스가 다루는 핵심 개념(주문, 상품, 회원, 결제 등)을 명확히 정의한다.
   - 개발자는 코드 구조가 비즈니스 언어(Ubiquitous Language)를 반영하도록 설계한다.
2. **Bounded Context (경계된 문맥)**
   - 하나의 도메인이 독립적으로 관리되는 ‘영역’을 의미한다.
   - 예를 들어 “회원”이라는 개념은 여러 곳에서 쓰이지만,
     - **주문 컨텍스트**에서는 “주문자 ID” 정도의 정보만 필요하고,
     - **회원 컨텍스트**에서는 “프로필, 포인트, 등급” 정보가 필요하다.
   - 이 두 영역을 같은 DB 스키마에서 관리하면 결합이 강해진다.
     따라서 “회원 서비스”와 “주문 서비스”는 분리되어야 한다.
3. **이벤트 기반 통합(Event-Driven Architecture)**
   - 컨텍스트 간 통신은 동기식 API보다는 **이벤트 발행/구독 모델**이 적합하다.
   - 예: “주문 완료” 이벤트 → 결제 서비스가 이를 구독해 트랜잭션 처리.
   - 이를 통해 서비스 간 결합도를 낮추고, 확장성을 높인다.
4. **도메인 기준 서비스 분리 절차 (예시)**
   1. 비즈니스 프로세스를 식별한다.
   2. 각 프로세스의 주요 개념(Entity)과 책임을 정의한다.
   3. 관련된 기능들을 하나의 컨텍스트로 묶는다.
   4. 컨텍스트 간 데이터·이벤트 흐름을 설계한다.
   5. API 또는 메시지 기반으로 통신을 설계한다.



## 정리

MSA는 단순히 기술 구조의 변화가 아니라, **조직 운영 방식의 진화**이다. 서비스를 나누는 이유는 기술 트렌드를 따르기 위해서가 아니라, **비즈니스 변화 속도를 높이고 팀이 자율적으로 움직이기 위함**이다.

MSA의 핵심은 “작은 단위의 자율성과 빠른 피드백 루프”이며, 그 성공의 열쇠는 **DDD 기반의 서비스 경계 정의**와 **자동화된 운영 체계**다.