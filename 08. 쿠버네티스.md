# 08. 쿠버네티스



## 8-1. 쿠버네티스 아키텍처와 주요 컴포넌트

### 개요

쿠버네티스(Kubernetes, 약칭 K8s)는 컨테이너의 배포·스케일링·복구·롤링업데이트를 자동화하는 **컨테이너 오케스트레이션 플랫폼**이다. Google의 내부 시스템 **Borg**를 기반으로 만들어졌으며, 현재는 **클라우드 네이티브 컴퓨팅 재단(CNCF)** 이 관리한다.

쿠버네티스의 철학은 “**선언형(Declarative)**”이다. 개발자는 “무엇을 원하는지(desired state)”만 선언하면, 쿠버네티스가 그 상태를 유지하도록 지속적으로 조정한다(Reconciliation Loop).

### 전체 구조

쿠버네티스 클러스터는 **Control Plane(제어 영역)** 과 **Worker Node(작업 노드)** 로 구성된다.

#### Control Plane

- **API Server**
  쿠버네티스의 핵심 진입점.
  `kubectl`, Dashboard, Helm 등 모든 요청이 API Server를 통해 들어온다.
  인증, 인가, 검증, 요청 전달을 담당한다.
- **etcd**
  클러스터의 모든 상태 데이터를 저장하는 **분산 Key-Value 저장소**.
  (Pod 스케줄링 정보, 설정, 상태 등)
- **Scheduler**
  새로 생성된 Pod를 적절한 Node에 배치.
  CPU/메모리/노드 상태 등을 고려해 최적의 위치를 결정.
- **Controller Manager**
  클러스터의 현재 상태를 모니터링하고,
  선언된 상태(desired state)와 실제 상태(actual state)가 다르면 자동으로 수정.
  (예: Deployment → Pod 재생성)

#### Worker Node

- **Kubelet**
  각 노드에서 컨테이너의 실행을 관리.
  Pod의 상태를 감시하고, API Server에 보고한다.
- **Container Runtime**
  실제 컨테이너를 실행하는 엔진.
  Docker, containerd, CRI-O 등이 사용된다.
- **Kube-Proxy**
  서비스 간 네트워크 트래픽을 라우팅하고, 로드밸런싱을 수행.

## 8-2. 핵심 리소스: Pod, Service, Deployment, ConfigMap, Secret

쿠버네티스의 모든 구성 요소는 **리소스(Resource)** 로 표현된다. 리소스는 YAML로 정의되며, API Server에 등록되어 관리된다.

### Pod

- 쿠버네티스에서 **가장 작은 배포 단위(Unit of Deployment)**.
- 하나 이상의 컨테이너(주로 1개)를 포함하고, 스토리지와 네트워크를 공유한다.
- 컨테이너는 Pod 내부에서 `localhost`로 통신 가능.
- Pod는 일시적(단명성)이며, 죽으면 새로 생성된다. -> **stateless**

### Service

- Pod는 언제든 재시작되거나 새 IP로 바뀔 수 있다.
- 따라서 안정적인 접근을 위해 Service라는 **고정 가상 IP(ClusterIP)** 를 제공한다.
- Service는 내부 로드밸런서 역할을 하며, Pod를 선택(`selector`)해 트래픽을 분산시킨다.
- 주요 타입:
  - **ClusterIP**: 클러스터 내부 통신용 (기본)
  - **NodePort**: 외부에서 노드의 포트로 접근
  - **LoadBalancer**: 클라우드 LB와 연동
  - **ExternalName**: DNS alias

### Deployment

- Pod의 **배포 전략, 개수, 롤링 업데이트**를 선언적으로 관리한다.
- 예: “항상 3개의 Pod를 유지하라.”
- 버전 업그레이드 시 새 Pod를 띄우고, 기존 Pod를 순차적으로 종료하여 **무중단 배포(Rolling Update)** 를 실현한다.

### ConfigMap & Secret

- **ConfigMap**
  비민감한 설정 정보(환경 변수, 설정 파일 등)를 외부에서 주입.
  예: 데이터베이스 URL, API 엔드포인트.
  → 애플리케이션 이미지를 다시 빌드하지 않고 설정만 교체 가능.
- **Secret**
  비밀번호, 토큰, 인증서 등 **민감한 정보** 저장용.
  Base64로 인코딩되어 저장되며, 실행 시 Pod 환경 변수나 Volume으로 마운트된다.
  보안을 위해 RBAC 및 암호화 설정이 병행되어야 한다.

## 8-3. 네트워킹과 Ingress

### 쿠버네티스 네트워킹의 기본 원칙

1. 모든 Pod는 NAT 없이 서로 통신 가능해야 한다.
2. 모든 Node는 모든 Pod와 통신 가능해야 한다.
3. 각 Pod는 고유한 IP를 갖는다.

이 원칙 덕분에 **“Pod-to-Pod”** 통신이 투명하게 가능하다. 클러스터 내부의 서비스들은 IP와 DNS를 통해 자동으로 해석된다(CoreDNS).

### Ingress: 클러스터의 ‘출입문’

- 외부 사용자가 클러스터 내부 서비스에 접근할 수 있게 하는 **HTTP 진입점**.
- 도메인 기반 라우팅, TLS(HTTPS), 리다이렉트 등 고급 기능을 제공한다.
- 예:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: myapp-ingress
spec:
  rules:
    - host: myapp.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: myapp-service
                port:
                  number: 80
```

- 대표 구현체: **Nginx Ingress Controller**, **Traefik**, **AWS ALB Controller** 등.

> 💡 **실무 팁:**
>
> - Ingress는 “로드밸런서 + 리버스 프록시”의 역할을 하며, SSL 종료(TLS Termination)도 담당한다.
> - 마이크로서비스 수가 많다면 Ingress → API Gateway(인증, 라우팅, 집계)로 확장하는 것이 일반적이다.

## 8-4. 스케일링과 자동화 (HPA, VPA)

쿠버네티스의 진정한 힘은 **자동 복구(Self-healing)** 와 **자동 확장(Autoscaling)** 에 있다.

### HPA (Horizontal Pod Autoscaler)

- CPU, 메모리, 커스텀 메트릭을 기반으로 Pod 수를 자동으로 조절한다.
- 예: CPU 사용률이 70%를 넘으면 Pod를 2→4개로 늘린다.
- `metrics-server`를 통해 실시간 리소스 사용량을 모니터링한다.
- 트래픽이 줄면 자동으로 축소되어 비용을 절감한다.

### VPA (Vertical Pod Autoscaler)

- Pod의 리소스 요청/제한(`requests`/`limits`) 값을 자동 조정한다.
- 예: 애플리케이션이 지속적으로 OOM(Out of Memory)이면 메모리 한도를 상향 조정.
- 장기적인 성능 최적화에 유용하지만, **Pod 재시작**이 발생할 수 있으므로 운영 환경에서는 신중히 적용.

### Cluster Autoscaler

- 노드 단위 확장.
  Pod를 더 배치할 곳이 없을 때 클라우드 API(AWS, GCP, Azure)를 호출해 새 노드를 추가한다.

> 💡 **운영 팁:**
>
> - HPA + Cluster Autoscaler 조합이 가장 일반적이다.
> - 메트릭은 Prometheus Adapter나 CloudWatch Metrics 등으로 연계 가능.

## 8-5. 헬름(Helm) 차트 관리

Helm은 **쿠버네티스의 패키지 관리자**다. 여러 YAML 파일을 일일이 적용하는 대신, 하나의 **Chart(템플릿 묶음)** 으로 관리한다.

- **Chart**: 애플리케이션 정의(templates + values).
- **Release**: Chart의 배포 인스턴스.
- **Repository**: Chart 저장소 (Artifact Hub, 사내 repo 등).

예를 들어, Spring Boot 서비스 + Service + Ingress + HPA 구성을 `values.yaml` 한 파일로 설정만 바꿔 여러 환경(dev/stg/prd)에 손쉽게 배포할 수 있다.

Helm은 다음 이점을 제공한다.

- 환경별 변수(values) 분리 → 코드 중복 감소
- 버전 관리, 롤백(`helm rollback`) 기능
- 공용 차트 재사용 (`bitnami/postgresql`, `nginx`, `prometheus` 등)

> 💡 **실무 팁:**
>
> - 사내 공통 컴포넌트(예: 로그 수집, 모니터링, 네트워크 정책)는 Helm Chart로 표준화.
> - CD 파이프라인에서 `helm upgrade --install` 을 사용해 자동 배포.
> - Helmfile 또는 ArgoCD와 연동하면 환경 간 차트 관리가 매우 효율적이다.

## 8-6. 정리 — 쿠버네티스는 “운영의 표준 언어”

Kubernetes는 컨테이너 인프라의 복잡성을 추상화하여, “**서비스를 선언하고, 시스템이 유지하도록 만든다**”는 운영 모델을 제공한다.

- Pod는 **실행 단위**, Service는 **통신 단위**, Deployment는 **배포 단위**
- ConfigMap/Secret은 **설정 단위**, Ingress는 **외부 진입점**
- HPA/VPA는 **자동화 단위**, Helm은 **관리 단위**

이 모든 것이 유기적으로 연결되면서 애플리케이션은 더 이상 ‘서버 위의 코드’가 아니라 ‘정의된 상태를 유지하는 선언적 객체’로 진화한다. 즉, Kubernetes는 클라우드 네이티브 시대의 **운영체계(Operating System for the Cloud)** 라 할 수 있다.
