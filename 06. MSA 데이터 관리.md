# 06. MSA 데이터 관리



## **6-1. 들어가며**

> **“MSA의 진짜 복잡성은 데이터에서 온다”**

마이크로서비스 아키텍처(MSA)를 도입한 많은 팀들이 공통적으로 부딪히는 벽이 있다. 바로 “**데이터 정합성**”이다.

모놀리식 환경에서는 하나의 데이터베이스를 공유하기 때문에, 트랜잭션을 `BEGIN–COMMIT`으로 감싸는 것만으로도 일관성을 쉽게 보장할 수 있었다. 하지만 MSA로 서비스가 나뉘면, 각 서비스가 고유의 데이터 저장소를 가지게 되고, 트랜잭션 경계가 네트워크를 넘어 분산된다.

이제 데이터는 더 이상 하나의 진실(single source of truth)이 아니며, **“분산된 진실들(distributed truths)”** 을 관리하는 기술과 설계 철학이 필요해진다.



## **6-2. Database per Service 패턴**

**🔹 개념**

MSA의 기본 원칙 중 하나는 **Database per Service**, 즉 “각 서비스가 자신의 데이터베이스를 독립적으로 소유한다”는 것이다. 이는 단순한 기술적 분리가 아니라, **서비스 경계(Bounded Context)** 를 지키기 위한 핵심 원칙이다.

예를 들어,

- 주문 서비스는 `orders` DB만,
- 결제 서비스는 `payments` DB만,
- 재고 서비스는 `inventory` DB만,

관리해야 한다.

**🔹 이유**

1. **결합도 최소화**
   - 공용 DB를 공유하면 스키마 변경이 전체에 영향을 준다.
   - 서비스별 DB로 분리하면, 각 팀이 독립적으로 개발할 수 있다.
2. **확장성 확보**
   - 트래픽이 몰리는 서비스만 개별적으로 scale-out 할 수 있다.
3. **보안 및 데이터 접근 통제**
   - 최소 권한 원칙(Least Privilege): 다른 서비스는 API를 통해서만 접근 가능하다.

**🔹 실무 고려사항**

- 단순히 DB 인스턴스를 나누는 것이 아니라, **도메인 모델을 분리**해야 한다.
- 서비스 간 데이터 참조는 직접 조인 대신 **API 호출 또는 이벤트 복제**로 해결한다.
- “데이터 중복”은 필연적이다. 이를 비용으로 받아들이고 정합성 보완 장치를 둔다.

💡 **Tip**: DB를 분리하면 “데이터는 불일치할 수 있다”는 사실을 전제로 시스템을 설계해야 한다. 대신, 장애 격리와 확장성, 배포 독립성을 얻게 된다.



## **6-3. 분산 데이터 관리 전략**

**🔹 1) API Composition**

여러 서비스의 데이터를 **API를 통해 조합**하는 방식이다. 예를 들어, 주문 상세를 조회할 때 주문 서비스에서 주문 정보를, 상품 서비스에서 상품 정보를 각각 API로 조회하여 조합한다.

- 장점: 단순하고 실시간으로 최신 데이터를 가져온다.
- 단점: 네트워크 지연 및 호출 실패에 취약하다.→ 캐시나 Aggregator 패턴으로 보완 필요.

**🔹 2) Command/Query Responsibility Segregation (CQRS)**

명령(쓰기)과 조회(읽기)를 분리하는 패턴이다. 데이터 쓰기는 각 서비스가 담당하지만, 조회는 여러 데이터를 합쳐 미리 가공된 뷰를 사용한다. 주로 **읽기 부하가 큰 서비스**(상품 검색, 주문 목록 등)에 사용된다.

**🔹 3) Event-Carried State Transfer (이벤트 기반 데이터 복제)**

한 서비스에서 데이터가 변경되면 “이벤트”를 발행하고, 다른 서비스가 이를 구독해 자신의 로컬 캐시에 데이터를 복제해둔다.

예:

- 상품 서비스 → `ProductPriceChanged` 이벤트 발행
- 주문 서비스 → 해당 이벤트를 구독하여 `product_price` 필드 업데이트

이 방식은 일시적인 데이터 불일치를 감수하지만, 서비스 간 결합을 줄이고 성능을 극대화할 수 있다.

**🔹 4) Saga 패턴 (분산 트랜잭션 처리)**

하나의 비즈니스 트랜잭션이 여러 서비스에 걸쳐 있을 때, 이를 **이벤트 시퀀스와 보상 트랜잭션(compensating transaction)** 으로 관리하는 패턴이다.

- 코레오그래피(Choreography): 이벤트 기반으로 각 서비스가 다음 단계 실행
- 오케스트레이션(Orchestration): 중앙 조정자가 순서를 관리

💡 **Tip:** Saga는 데이터의 완벽한 동기화를 보장하지 않는다. 대신, **비즈니스 단위의 일관성(Business Consistency)** 을 보장한다.



## **6-4. 데이터 일관성 문제와 해결 방안**

**🔹 일관성(consistency)의 종류**

| **유형**                 | **설명**                                             | **예시**               |
| ------------------------ | ---------------------------------------------------- | ---------------------- |
| **Strong Consistency**   | 즉시 일치. 트랜잭션 커밋 후 모든 노드가 동일한 상태. | 전통적 RDBMS           |
| **Eventual Consistency** | 시간이 지나면 일치. 일시적 불일치는 허용.            | 대부분의 MSA           |
| **Causal Consistency**   | 인과관계가 있는 변경만 순서 보장.                    | 분산 캐시, SNS 피드 등 |

MSA에서는 현실적으로 **Eventual Consistency** 가 기본이다. 따라서 일관성 보다는 **결과적 정합성**과 **보상 로직**으로 설계를 보완한다.

**🔹 해결 패턴**

1. **Outbox 패턴**
   - 서비스의 로컬 트랜잭션 내에서 이벤트를 함께 저장한 뒤, 별도 프로세스(Outbox Processor)가 안전하게 브로커로 발행한다.
   - 데이터베이스와 메시지 발행 간 **원자성**을 확보하는 방식이다.
2. **Idempotency (멱등성)**
   - 같은 요청이 여러 번 들어와도 결과가 한 번만 적용되도록 설계한다.
   - 예: “주문 생성 API”가 중복 호출돼도 주문은 한 번만 생성.
   - 키 기반으로 중복 이벤트/요청을 필터링.
3. **Retry & Dead Letter Queue(DLQ)**
   - 실패한 이벤트는 재시도, 일정 횟수 초과 시 DLQ로 이동해 수동 복구.
4. **보상 트랜잭션(Compensation)**
   - 실패 시 이전 단계의 상태를 되돌리는 로직.
   - 예: 결제 취소, 포인트 회수 등.
5. **Consistency Validation Job**
   - 주기적으로 서비스 간 데이터 정합성을 점검하고 불일치 건을 보정하는 배치 잡 또는 스크립트를 운영.



## **6-5. 폴리글랏 퍼시스턴스 (Polyglot Persistence)**

**🔹 개념**

“한 가지 데이터베이스로 모든 문제를 해결할 수 없다”는 현실적 인식에서 나온 개념이다. 서비스별 특성과 데이터 성격에 맞춰 **서로 다른 저장소 기술을 혼합 사용**한다는 뜻이다.

| **서비스**  | **데이터 특성**        | **추천 저장소 예시**              |
| ----------- | ---------------------- | --------------------------------- |
| 주문 서비스 | 트랜잭션, 관계형       | RDBMS (PostgreSQL, MySQL, Oracle) |
| 상품 서비스 | 검색·필터링 중심       | Elasticsearch                     |
| 세션/캐시   | 빠른 읽기, 단기성      | Redis, Memcached                  |
| 로그·이벤트 | 순차적 기록, 대량 저장 | Kafka, S3, ClickHouse             |
| 추천·분석   | 비정형, 통계 연산      | MongoDB, Cassandra, BigQuery      |



## **6-6. 정리**

MSA의 핵심은 **서비스의 독립성**이고, 데이터 관리는 그 독립성을 **데이터 수준에서 실현하는 일**이다.

- **Database per Service** 로 경계를 지키고,
- **Event 기반 복제**와 **Saga** 로 일관성을 유지하며,
- **Outbox·Idempotency·DLQ** 로 신뢰성을 확보하고,
- **Polyglot Persistence** 로 각 도메인에 최적화된 스토리지를 선택한다.

이것이 곧 “**분산 환경에서도 데이터로부터 안정성을 잃지 않는 법**”이며, 현대적 백엔드 시스템의 지속가능성을 결정짓는 가장 실질적인 영역이다.