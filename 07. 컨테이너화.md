# 07. 컨테이너화



## **7-1. Docker 기초와 이미지 관리**

> “동일한 실행 환경을 캡슐화한다”

컨테이너화의 핵심 가치는 **“어디서든 똑같이 실행되는 애플리케이션”** 이다. 개발자의 노트북, CI 서버, 운영 클러스터가 서로 다른 OS·패키지 버전을 쓰더라도, 애플리케이션과 그 의존성(JDK, 라이브러리, OS 패키지)을 **이미지**로 묶어 배포하면 **실행 결과를 예측 가능**하게 만든다.

- **이미지(Image)**: 읽기 전용 스냅샷. 레이어(layer)의 누적으로 구성된다. 베이스 이미지(예: `eclipse-temurin:21-jre`) 위에 어플리케이션 레이어가 쌓인다.
- **컨테이너(Container)**: 이미지를 실행한 “프로세스 인스턴스”. 컨테이너는 가볍고 빠르게 뜨며, 죽이면 깨끗이 사라진다.
- **레지스트리(Registry)**: 이미지를 저장·배포하는 저장소. Docker Hub, ECR, GCR 등. 조직은 보통 **프라이빗 레지스트리**를 운영한다.

이미지 관리는 **버전 태깅**과 **취약점 스캐닝**, **용량 최적화**가 관건이다. `latest`만 쓰면 추적이 안 되니, 보통 `app:1.8.3`(버전) + `gitsha`(불변성) 태그를 병행하고, CI 단계에서 이미지 스캔(트리비/Grype 등)을 자동화한다. 레이어 수와 용량을 줄여 **푸시/풀 시간과 네트워크 비용**도 관리한다.



## **7-2. 컨테이너 오케스트레이션의 필요성**

> “대규모 운영은 스케줄러에게 맡기자”

컨테이너 한두 개일 때는 `docker run`으로 충분하지만, 마이크로서비스처럼 **수십~수백 개 컨테이너**를 운영하려면 다음 문제가 등장한다.

- **스케줄링**: 어떤 노드에, 몇 개의 인스턴스를 띄울 것인가?
- **자가 치유(Self-healing)**: 죽은 컨테이너를 자동으로 재시작할 것인가?
- **오토스케일링**: 트래픽 증가 시 자동으로 개수를 늘릴 것인가?
- **서비스 디스커버리/네트워킹**: IP가 바뀌어도 안정적 접근이 가능해야 한다.
- **롤링 업데이트/롤백**: 무중단 배포와 빠른 복귀가 가능해야 한다.
- **비밀/설정 관리**: 환경 변수, 시크릿, ConfigMap 등 표준화가 필요하다.

이 모든 걸 사람이 수동으로 할 수 없으니, **오케스트레이터**(대표적으로 Kubernetes)가 필요하다. K8s는 선언형 매니페스트로 “원하는 상태”를 기술하면, 클러스터가 그 상태를 **지속적으로 유지**한다. 이를 통해 **가용성·확장성·복원력**을 자동으로 확보한다. (작은 규모면 Docker Compose, ECS 같은 대안도 가능하지만, 장기적으로는 K8s가 표준에 가깝다.)



## **7-3. Dockerfile 작성 베스트 프랙티스**

> “작고, 빠르고, 안전하게”

**목표**는 세 가지:

1. **용량 최소화**(푸시/풀 빠르게)
2. **빌드 캐시 최적화**(CI 속도)
3. **보안/재현성**(취약점·의존 고정).

핵심 원칙을 정리하면:

1. **슬림한 베이스 이미지**
   - JRE만 필요한 Spring Boot 런타임에는 `eclipse-temurin:21-jre` 같은 슬림 이미지 사용.
   - 가능하면 distroless(셸 없음)로 공격면 축소. 디버그 용도로만 shell 베리에이션 유지.
2. **빌드와 런타임 분리(멀티 스테이지)**
   - 빌드 도구(Gradle/Maven)·캐시·테스트 종속성은 **빌드용 스테이지**에서만 사용하고, 런타임 스테이지에는 **완성된 산출물(jar)** 만 복사한다. 운영 이미지가 **가벼워지고 안전**해진다.
3. **의존(Dependency) 캐시 고정**
   - `COPY build.gradle settings.gradle ...` → `RUN gradle dependencies` 순으로 캐시 레이어를 만들면, 소스만 바뀌었을 때 **의존 재다운로드를 피함**(CI 가속).
   - Maven도 동일 패턴(`pom.xml` 캐시).
4. **애플리케이션 사용자 분리**
   - 컨테이너 내부 실행 유저를 `root`에서 **비특권 사용자**로 변경하여 권한을 최소화.
5. **환경 변수/시크릿 분리**
   - 비밀값을 이미지에 bake-in 하지 말고, 런타임에 **환경 변수/시크릿**으로 주입. (K8s Secret, AWS SM 등)
6. **헬스체크/포트/타임존**
   - `HEALTHCHECK`로 자체 진단 엔드포인트(`/actuator/health`) 점검.
   - 내부 포트 `EXPOSE 8080` 등 명시(문서화 목적).
   - 타임존 필요하면 명시적 설정(가능하면 UTC 고정 + 앱 레벨에서 TZ 처리).
7. **로그는 표준 출력으로**
   - 파일로 쓰지 말고 **stdout/stderr** 로. 오케스트레이터/에이전트가 수집한다.



## **7-4. 멀티 스테이지 빌드**

> **“운영 이미지는 결과물만”**

멀티 스테이지는 **빌드 과정**과 **실행 환경**을 한 Dockerfile 안에서 **분리**하는 기법이다. 이 덕분에 최종 이미지는 **불필요한 도구(컴파일러, 캐시, 테스트 리소스)** 를 포함하지 않아 **용량과 공격면**이 크게 줄어든다.

**Spring Boot(Gradle) 예시**

```docker
# ---- Build stage ----
FROM eclipse-temurin:21-jdk AS build
WORKDIR /app

# gradle wrapper & 설정 파일만 먼저 복사 → 의존성 캐시
COPY gradlew gradlew
COPY gradle gradle
COPY build.gradle settings.gradle ./
RUN ./gradlew --no-daemon dependencies || true

# 소스 복사 후 빌드
COPY src src
RUN ./gradlew --no-daemon clean bootJar

# ---- Runtime stage ----
FROM eclipse-temurin:21-jre AS runtime
WORKDIR /app

# 비특권 사용자 생성
RUN useradd -u 10001 -r -s /sbin/nologin appuser

# 빌드 산출물만 복사
COPY --from=build /app/build/libs/*.jar app.jar

# 헬스체크(스프링 액추에이터 사용 가정)
HEALTHCHECK --interval=30s --timeout=3s CMD curl -f <http://localhost:8080/actuator/health> || exit 1

EXPOSE 8080
USER appuser
ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app/app.jar"]
```

이점

- 최종 런타임 이미지는 JRE + `app.jar`만 포함 → **작고 안전**
- 빌드 스테이지의 Gradle 캐시 활용 → **CI시간 단축**
- 유저 권한 최소화, 헬스체크 등 운영 친화적

**추가 최적화 아이디어**

- **Layering Jar**(Spring Boot `layers.idx`)를 이용해 빈번히 바뀌는 코드 레이어만 갱신 → 캐시 타격 최소화
- **JVM 옵션 컨테이너 인식**(`XX:+UseContainerSupport`) 및 메모리 한도(`Xms/-Xmx`) 환경화
- **Distroless** 런타임 전환으로 CVE 표면 축소(디버깅 경로 별도 마련)



## **7-5. 마무리**

> “컨테이너는 제품, 오케스트레이션은 운영체계”

컨테이너는 **일관된 실행 패키지**를 만들어주고, 오케스트레이션은 그 패키지의 **수명주기**를 관리한다. 좋은 Dockerfile은 작은 용량·빠른 빌드·낮은 취약점을 갖추고, 좋은 클러스터 운영은 **자가치유·오토스케일링·관찰성**을 기본 탑재한다.

결국 컨테이너화의 목표는 “개발과 운영의 경계를 낮추어 **더 빨리, 더 안전하게** 배포”하는 데 있다. 멀티 스테이지와 베스트 프랙티스를 습관화하면, 이 목표에 가장 짧은 경로로 도달할 수 있다.